const nodemailer = require('nodemailer');
const path = require('path');
const fs = require('fs').promises;
const ejs = require('ejs');
const NodeCache = require('node-cache');
const { v4: uuidv4 } = require('uuid');

const __dirname = path.dirname(require.main.filename);

// Email configuration
const EMAIL_CONFIG = {
  // Retry configuration
  MAX_RETRIES: 3,
  INITIAL_RETRY_DELAY: 1000, // 1 second
  MAX_RETRY_DELAY: 30000, // 30 seconds
  
  // Connection settings
  POOL: true,
  MAX_CONNECTIONS: 5,
  
  // Default from email
  DEFAULT_FROM: `"${process.env.EMAIL_FROM_NAME || 'Byblos Experience'}" <${process.env.EMAIL_FROM_EMAIL}>`,
  DEFAULT_REPLY_TO: process.env.EMAIL_REPLY_TO || process.env.EMAIL_FROM_EMAIL,
  
  // Timeouts (in milliseconds)
  CONNECTION_TIMEOUT: 10000, // 10 seconds
  SEND_TIMEOUT: 30000, // 30 seconds
  
  // Security
  SECURE: process.env.EMAIL_SECURE === 'true',
};

// Cache for email templates and other static data
const emailCache = new NodeCache({
  stdTTL: 3600, // 1 hour cache
  checkperiod: 600, // Check for expired items every 10 minutes
  useClones: false, // Better performance for our use case
  maxKeys: 1000,
});

// Cache for rendered templates (5 min TTL)
const templateRenderCache = new NodeCache({
  stdTTL: 300, // 5 minutes
  maxKeys: 1000,
  useClones: false,
});

// Default template data that will be available in all templates
const defaultTemplateData = {
  appName: process.env.APP_NAME || 'Byblos Experience',
  currentYear: new Date().getFullYear(),
  supportEmail: process.env.SUPPORT_EMAIL || 'support@byblos.com',
  baseUrl: process.env.FRONTEND_URL || 'http://localhost:3000',
};

/**
 * Helper function to create transporter with retry logic and enhanced configuration
 * @returns {import('nodemailer').Transporter} Configured nodemailer transporter
 */
const createTransporter = () => {
  // Validate required environment variables
  const requiredVars = [
    'EMAIL_HOST', 
    'EMAIL_PORT', 
    'EMAIL_USERNAME', 
    'EMAIL_PASSWORD', 
    'EMAIL_FROM_EMAIL', 
    'EMAIL_FROM_NAME'
  ];
  
  const missingVars = requiredVars.filter(varName => !process.env[varName]);
  
  if (missingVars.length > 0) {
    const errorMsg = `Missing required email configuration: ${missingVars.join(', ')}`;
    console.error(`[${new Date().toISOString()}] ${errorMsg}`);
    throw new Error(errorMsg);
  }

  // Validate required configuration
  if (!process.env.EMAIL_HOST || !process.env.EMAIL_PORT || !process.env.EMAIL_USERNAME || !process.env.EMAIL_PASSWORD) {
    throw new Error('Missing required email configuration. Please check your .env file.');
  }

  console.log('Creating email transporter with config:', {
    host: process.env.EMAIL_HOST,
    port: process.env.EMAIL_PORT,
    secure: process.env.EMAIL_SECURE,
    user: process.env.EMAIL_USERNAME,
  });

  // Create transporter with Zoho SMTP settings
  const transporter = nodemailer.createTransport({
    host: process.env.EMAIL_HOST,
    port: parseInt(process.env.EMAIL_PORT, 10),
    secure: true, // Zoho requires SSL/TLS
    auth: {
      user: process.env.EMAIL_USERNAME,
      pass: process.env.EMAIL_PASSWORD,
    },
    tls: {
      // Do not fail on invalid certs in development
      rejectUnauthorized: process.env.NODE_ENV === 'production',
    },
    pool: EMAIL_CONFIG.POOL,
    maxConnections: EMAIL_CONFIG.MAX_CONNECTIONS,
    connectionTimeout: EMAIL_CONFIG.CONNECTION_TIMEOUT,
    greetingTimeout: 15000,
    socketTimeout: 60000,
    debug: process.env.NODE_ENV === 'development',
    logger: process.env.NODE_ENV === 'development' ? {
      debug: (message, ...args) => console.debug(`[EMAIL_DEBUG] ${message}`, ...args),
      info: (message, ...args) => console.info(`[EMAIL_INFO] ${message}`, ...args),
      warn: (message, ...args) => console.warn(`[EMAIL_WARN] ${message}`, ...args),
      error: (message, ...args) => console.error(`[EMAIL_ERROR] ${message}`, ...args),
      log: (message, ...args) => console.log(`[EMAIL_LOG] ${message}`, ...args)
    } : false,
  });
};

// Create a singleton transporter instance with retry logic
let transporter;
let lastTransporterError = null;
let transporterRetryCount = 0;
const MAX_TRANSPORTER_RETRIES = 5;

/**
 * Get or create the email transporter with retry logic
 * @returns {Promise<import('nodemailer').Transporter>} Configured nodemailer transporter
 */
const getTransporter = async () => {
  if (transporter) return transporter;
  
  try {
    console.log(`[${new Date().toISOString()}] Creating new email transporter (attempt ${transporterRetryCount + 1}/${MAX_TRANSPORTER_RETRIES})`);
    
    // Create a new transporter
    transporter = createTransporter();
    
    // Verify the connection
    await new Promise((resolve, reject) => {
      transporter.verify((error) => {
        if (error) {
          console.error(`[${new Date().toISOString()}] Email transport verification failed:`, error);
          reject(error);
        } else {
          console.log(`[${new Date().toISOString()}] Email transport configuration is valid`);
          resolve();
        }
      });
    });
    
    // Reset retry counter on success
    transporterRetryCount = 0;
    lastTransporterError = null;
    
    return transporter;
  } catch (error) {
    transporterRetryCount++;
    lastTransporterError = error;
    
    if (transporterRetryCount >= MAX_TRANSPORTER_RETRIES) {
      console.error(`[${new Date().toISOString()}] Max retries (${MAX_TRANSPORTER_RETRIES}) reached for email transporter creation`);
      throw new Error(`Failed to initialize email transporter after ${MAX_TRANSPORTER_RETRIES} attempts: ${error.message}`);
    }
    
    // Wait with exponential backoff before retrying
    const delay = Math.min(1000 * Math.pow(2, transporterRetryCount), 30000);
    console.log(`[${new Date().toISOString()}] Retrying transporter creation in ${delay}ms...`);
    
    await new Promise(resolve => setTimeout(resolve, delay));
    return getTransporter();
  }
};

// Initialize the transporter on startup if in production
if (process.env.NODE_ENV === 'production') {
  getTransporter().catch(error => {
    console.error(`[${new Date().toISOString()}] Failed to initialize email transporter on startup:`, error);
  });
}

/**
 * Get the path to an email template
 * @param {string} templateName - Name of the template (without extension)
 * @returns {Promise<string>} Absolute path to the template file
 */
const getTemplatePath = async (templateName) => {
  const templatePath = join(__dirname, `../../email-templates/${templateName}.ejs`);
  
  try {
    await fs.access(templatePath);
    return templatePath;
  } catch (error) {
    // Try alternative template locations
    const altPaths = [
      join(__dirname, `../email-templates/${templateName}.ejs`),
      join(__dirname, `./templates/${templateName}.ejs`),
      join(process.cwd(), `email-templates/${templateName}.ejs`),
    ];
    
    for (const path of altPaths) {
      try {
        await fs.access(path);
        console.log(`[${new Date().toISOString()}] Found template at alternative path: ${path}`);
        return path;
      } catch (e) {
        // Ignore and try next path
      }
    }
    
    throw new Error(`Template not found: ${templateName}.ejs (tried ${templatePath} and ${altPaths.join(', ')})`);
  }
};

/**
 * Read and compile email templates with caching
 * @param {string} templateName - Name of the template to compile (without extension)
 * @returns {Promise<ejs.TemplateFunction>} Compiled EJS template function
 */
const compileTemplate = async (templateName) => {
  const cacheKey = `template:${templateName}`;
  
  try {
    // Check cache first
    const cachedTemplate = emailCache.get(cacheKey);
    if (cachedTemplate) {
      return cachedTemplate;
    }
    
    // Get template path
    const templatePath = await getTemplatePath(templateName);
    
    // Read template file with retry logic
    let templateContent;
    const maxRetries = 3;
    let lastError;
    
    for (let i = 0; i < maxRetries; i++) {
      try {
        templateContent = await fs.readFile(templatePath, 'utf-8');
        lastError = null;
        break;
      } catch (error) {
        lastError = error;
        if (i < maxRetries - 1) {
          // Wait before retrying (exponential backoff)
          await new Promise(resolve => setTimeout(resolve, 100 * Math.pow(2, i)));
        }
      }
    }
    
    if (lastError) {
      throw new Error(`Failed to read template file after ${maxRetries} attempts: ${lastError.message}`);
    }
    
    // Compile template with error handling
    let compiledTemplate;
    try {
      compiledTemplate = ejs.compile(templateContent, {
        filename: templatePath,
        cache: true,
        async: true,
        root: [
          join(__dirname, '../../email-templates'),
          join(__dirname, '../email-templates'),
          join(__dirname, './templates'),
          process.cwd(),
        ],
        views: [
          join(__dirname, '../../email-templates'),
          join(__dirname, '../email-templates'),
          join(__dirname, './templates'),
          process.cwd(),
        ],
        compileDebug: process.env.NODE_ENV !== 'production',
        client: false,
        strict: false,
        _with: true,
        localsName: 'data',
      });
    } catch (compileError) {
      throw new Error(`Failed to compile template ${templateName}: ${compileError.message}`);
    }
    
    // Cache the compiled template
    emailCache.set(cacheKey, compiledTemplate);
    
    return compiledTemplate;
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error in compileTemplate('${templateName}'):`, error);
    throw error;
  }
};

/**
 * Render email template with data and caching
 * @param {string} templateName - Name of the template to render (without extension)
 * @param {Object} data - Data to pass to the template
 * @param {boolean} [useCache=true] - Whether to use cached rendered templates (default: true)
 * @returns {Promise<string>} Rendered HTML content
 */
const renderTemplate = async (templateName, data = {}, useCache = true) => {
  const startTime = Date.now();
  const cacheKey = `render:${templateName}:${JSON.stringify(data)}`;
  
  try {
    // Check render cache if enabled
    if (useCache) {
      const cachedRender = templateRenderCache.get(cacheKey);
      if (cachedRender) {
        const duration = Date.now() - startTime;
        console.log(`[${new Date().toISOString()}] [CACHE_HIT] Rendered template '${templateName}' in ${duration}ms`);
        return cachedRender;
      }
    }
    
    // Get the compiled template
    const template = await compileTemplate(templateName);
    
    // Merge with default data
    const templateData = {
      ...defaultTemplateData,
      ...data,
      // Add utility functions that can be used in templates
      _: {
        // Format currency
        currency: (amount, currency = 'KES') => {
          return new Intl.NumberFormat('en-KE', {
            style: 'currency',
            currency,
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
          }).format(amount);
        },
        // Format date
        date: (date, format = 'medium') => {
          const options = {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
          };
          
          if (format === 'short') {
            options.month = 'short';
            options.weekday = 'short';
          } else if (format === 'long') {
            options.weekday = 'long';
          }
          
          return new Date(date).toLocaleDateString('en-US', options);
        },
        // Truncate text
        truncate: (text, length = 100, suffix = '...') => {
          if (!text || typeof text !== 'string') return '';
          if (text.length <= length) return text;
          return text.substring(0, length) + suffix;
        },
      },
    };
    
    // Render the template
    const rendered = await new Promise((resolve, reject) => {
      template(templateData, (error, result) => {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      });
    });
    
    // Cache the rendered template if caching is enabled
    if (useCache) {
      templateRenderCache.set(cacheKey, rendered);
    }
    
    const duration = Date.now() - startTime;
    console.log(`[${new Date().toISOString()}] Rendered template '${templateName}' in ${duration}ms`);
    
    return rendered;
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error rendering template '${templateName}':`, error);
    
    // Return a user-friendly error message in production
    if (process.env.NODE_ENV === 'production') {
      return `
        <div style="font-family: Arial, sans-serif; padding: 20px; color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px;">
          <h2>Error Loading Email Content</h2>
          <p>We're sorry, but there was an error loading the email content. Please contact support if this issue persists.</p>
          <p><small>Error: ${error.message}</small></p>
        </div>
      `;
    }
    
};

/**
 * Calculate delay with jitter to avoid thundering herd
 * @param {number} attempt - Current attempt number (0-based)
 * @param {number} [baseDelay=EMAIL_CONFIG.INITIAL_RETRY_DELAY] - Base delay in ms
 * @param {number} [maxDelay=EMAIL_CONFIG.MAX_RETRY_DELAY] - Maximum delay in ms
 * @returns {number} Calculated delay in milliseconds
 */
const calculateDelay = (attempt, baseDelay = EMAIL_CONFIG.INITIAL_RETRY_DELAY, maxDelay = EMAIL_CONFIG.MAX_RETRY_DELAY) => {
  const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);
  const jitter = Math.random() * 0.5 * delay; // Add up to 50% jitter
  return Math.floor(delay + jitter);
};

/**
 * Validate email address format
 * @param {string} email - Email address to validate
 * @returns {boolean} True if email is valid
 */
const isValidEmail = (email) => {
  if (!email || typeof email !== 'string') return false;
  return EMAIL_CONFIG.EMAIL_REGEX.test(email.trim().toLowerCase());
};

/**
 * Validate URL format
 * @param {string} url - URL to validate
 * @returns {boolean} True if URL is valid
 */
const isValidUrl = (url) => {
  if (!url || typeof url !== 'string') return false;
  return EMAIL_CONFIG.URL_REGEX.test(url.trim().toLowerCase());
};

/**
 * Process and validate email attachments
 * @param {Array} attachments - Array of attachment objects
 * @returns {Promise<Array>} Processed attachments
 */
const processAttachments = async (attachments = []) => {
  if (!Array.isArray(attachments)) {
    throw new Error('Attachments must be an array');
  }
  
  if (attachments.length > EMAIL_CONFIG.MAX_TOTAL_ATTACHMENTS) {
    throw new Error(`Maximum of ${EMAIL_CONFIG.MAX_TOTAL_ATTACHMENTS} attachments allowed`);
  }
  
  const processedAttachments = [];
  let totalSize = 0;
  
  for (const [index, attachment] of attachments.entries()) {
    try {
      // Validate required fields
      if (!attachment.filename) {
        throw new Error(`Attachment at index ${index} is missing required 'filename' property`);
      }
      
      // Process content if path is provided
      if (attachment.path && !attachment.content) {
        if (!isValidUrl(attachment.path)) {
          throw new Error(`Invalid URL in attachment at index ${index}: ${attachment.path}`);
        }
        
        // Fetch remote content
        const response = await axios.get(attachment.path, { 
          responseType: 'arraybuffer',
          maxContentLength: EMAIL_CONFIG.MAX_ATTACHMENT_SIZE,
          timeout: 10000, // 10 second timeout
        });
        
        if (response.status !== 200) {
          throw new Error(`Failed to fetch attachment from ${attachment.path}: ${response.statusText}`);
        }
        
        const content = Buffer.from(response.data);
        
        // Check size
        if (content.length > EMAIL_CONFIG.MAX_ATTACHMENT_SIZE) {
          throw new Error(`Attachment ${attachment.filename} exceeds maximum size of ${EMAIL_CONFIG.MAX_ATTACHMENT_SIZE / (1024 * 1024)}MB`);
        }
        
        totalSize += content.length;
        if (totalSize > EMAIL_CONFIG.MAX_ATTACHMENT_SIZE * 3) {
          throw new Error(`Total attachment size exceeds maximum of ${(EMAIL_CONFIG.MAX_ATTACHMENT_SIZE * 3) / (1024 * 1024)}MB`);
        }
        
        processedAttachments.push({
          ...attachment,
          content,
          // Remove path to avoid accidental refetching
          path: undefined,
        });
      } else if (attachment.content) {
        // Handle direct content
        const content = Buffer.isBuffer(attachment.content) 
          ? attachment.content 
          : Buffer.from(attachment.content);
        
        // Check size
        if (content.length > EMAIL_CONFIG.MAX_ATTACHMENT_SIZE) {
          throw new Error(`Attachment ${attachment.filename} exceeds maximum size of ${EMAIL_CONFIG.MAX_ATTACHMENT_SIZE / (1024 * 1024)}MB`);
        }
        
        totalSize += content.length;
        if (totalSize > EMAIL_CONFIG.MAX_ATTACHMENT_SIZE * 3) {
          throw new Error(`Total attachment size exceeds maximum of ${(EMAIL_CONFIG.MAX_ATTACHMENT_SIZE * 3) / (1024 * 1024)}MB`);
        }
        
        processedAttachments.push({
          ...attachment,
          content,
        });
      } else {
        throw new Error(`Attachment at index ${index} must have either 'content' or 'path' property`);
      }
    } catch (error) {
      console.error(`[${new Date().toISOString()}] Error processing attachment at index ${index}:`, error);
      throw new Error(`Failed to process attachment ${attachment.filename || 'unnamed'}: ${error.message}`);
    }
  }
  
  return processedAttachments;
};

/**
 * Simple promise-based delay
 * @param {number} ms - Milliseconds to delay
 * @returns {Promise<void>} Resolves after the specified delay
 */
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

/**
 * Fetch and cache images with retry logic and validation
 * @param {string} url - URL of the image to fetch
 * @param {Object} [options] - Fetch options
 * @param {number} [options.maxRetries=3] - Maximum number of retry attempts
 * @param {number} [options.timeout=10000] - Request timeout in milliseconds
 * @returns {Promise<{buffer: Buffer, contentType: string, size: number, url: string}>} Image data
 */
const fetchImage = async (url, options = {}) => {
  const startTime = Date.now();
  const { maxRetries = 3, timeout = 10000 } = options;
  const cacheKey = `image:${url}`;
  
  // Validate URL
  if (!url || typeof url !== 'string') {
    throw new Error('Invalid URL: URL must be a non-empty string');
  }
  
  try {
    // Check cache first
    const cachedImage = imageCache.get(cacheKey);
    if (cachedImage) {
      const duration = Date.now() - startTime;
      console.log(`[${new Date().toISOString()}] [CACHE_HIT] Fetched image from cache: ${url} (${cachedImage.size} bytes, ${duration}ms)`);
      return cachedImage;
    }
    
    console.log(`[${new Date().toISOString()}] Fetching image: ${url}`);
    
    // Fetch with retry logic
    let lastError;
    
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      try {
        const response = await fetch(url, {
          signal: controller.signal,
          headers: {
            'User-Agent': 'Byblos-Email-Service/1.0',
          },
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status} ${response.statusText}`);
        }
        
        const buffer = await response.buffer();
        const contentType = response.headers.get('content-type') || 'application/octet-stream';
        const contentLength = parseInt(response.headers.get('content-length') || '0', 10);
        
        // Validate content type
        const validImageTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml'];
        if (!validImageTypes.some(type => contentType.startsWith(type))) {
          throw new Error(`Unsupported content type: ${contentType}`);
        }
        
        // Validate size
        if (contentLength > EMAIL_CONFIG.MAX_ATTACHMENT_SIZE) {
          throw new Error(`Image size (${contentLength} bytes) exceeds maximum allowed size (${EMAIL_CONFIG.MAX_ATTACHMENT_SIZE} bytes)`);
        }
        
        // Cache the image
        const imageData = {
          buffer,
          contentType,
          size: buffer.length,
          url,
          cachedAt: new Date().toISOString(),
        };
        
        imageCache.set(cacheKey, imageData);
        
        const duration = Date.now() - startTime;
        console.log(`[${new Date().toISOString()}] Fetched image: ${url} (${buffer.length} bytes, ${duration}ms)`);
        
        return imageData;
      } catch (error) {
        lastError = error;
        clearTimeout(timeoutId);
        
        if (attempt < maxRetries - 1) {
          const delayMs = calculateDelay(attempt);
          console.warn(`[${new Date().toISOString()}] Attempt ${attempt + 1}/${maxRetries} failed (${error.message}). Retrying in ${delayMs}ms...`);
          await delay(delayMs);
        }
      }
    }
    
    throw new Error(`Failed to fetch image after ${maxRetries} attempts: ${lastError?.message || 'Unknown error'}`);
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error fetching image ${url}:`, error);
    throw error;
  }
};

/**
 * Send an email with retry logic and error handling
 * @param {Object} options - Email options
 * @param {string|string[]} options.to - Recipient email address(es)
 * @param {string} [options.subject] - Email subject
 * @param {string} [options.text] - Plain text version of the email
 * @param {string} [options.html] - HTML version of the email
 * @param {string} [options.template] - Template name (without .ejs extension)
 * @param {Object} [options.templateData] - Data to pass to the template
 * @param {Array} [options.attachments] - Array of attachment objects
 * @param {string} [options.from] - Sender email address
 * @param {string} [options.replyTo] - Reply-to email address
 * @param {string} [options.priority='normal'] - Email priority (high, normal, low)
 * @param {Object} [options.headers] - Custom headers to include in the email
 * @param {number} [retryCount=0] - Current retry attempt (internal use)
 * @returns {Promise<Object>} Email sending result
 */
const sendEmail = async (options, retryCount = 0) => {
  const startTime = Date.now();
  const emailId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

  // Validate email configuration
  if (process.env.EMAIL_ENABLED === 'false') {
    console.warn(`[${new Date().toISOString()}] [${emailId}] Email sending is disabled by configuration`);
    return { success: false, message: 'Email sending is disabled', emailId };
  }

  try {
    // Validate required options
    if (!options.to) {
      throw new Error('Recipient email address is required');
    }

    // Normalize recipients to array
    const recipients = Array.isArray(options.to) ? options.to : [options.to];

    // Validate email addresses
    const invalidEmails = recipients.filter(email => !isValidEmail(email));
    if (invalidEmails.length > 0) {
      throw new Error(`Invalid email address(es): ${invalidEmails.join(', ')}`);
    }

    // Validate subject or template
    if (!options.subject && !options.template) {
      throw new Error('Email subject or template is required');
    }

    // Validate content
    if (!options.text && !options.html && !options.template) {
      throw new Error('Email content (text, html, or template) is required');
    }

    // Get or create transporter
    const mailTransporter = await getTransporter();

    // Process template if provided
    if (options.template) {
      try {
        const templateStart = Date.now();
        options.html = await renderTemplate(options.template, options.templateData || {});
        console.log(`[${new Date().toISOString()}] [${emailId}] Rendered template '${options.template}' in ${Date.now() - templateStart}ms`);
      } catch (error) {
        console.error(`[${new Date().toISOString()}] [${emailId}] Error rendering email template:`, error);
        throw new Error(`Failed to render email template: ${error.message}`);
      }
    }

    // Prepare email options
    const mailOptions = {
      from: options.from || EMAIL_CONFIG.DEFAULT_FROM,
      to: options.to,
      subject: options.subject || 'No Subject',
      text: options.text,
      html: options.html,
      replyTo: options.replyTo || EMAIL_CONFIG.DEFAULT_REPLY_TO,
      priority: options.priority || 'normal',
      headers: {
        'X-Mailer': 'Byblos Email Service',
        'X-Auto-Response-Suppress': 'OOF, AutoReply',
        'Precedence': 'bulk',
        'X-Email-ID': emailId,
        'X-Environment': process.env.NODE_ENV || 'development',
        'X-Attempt': attempt,
        ...options.headers,
      },
      // Add envelope for better tracking
      envelope: {
        from: options.from || EMAIL_CONFIG.DEFAULT_FROM,
        to: options.to,
      },
    };

    // Process attachments if any
    if (options.attachments && options.attachments.length > 0) {
      try {
        const attachmentsStart = Date.now();
        mailOptions.attachments = await processAttachments(options.attachments);
        console.log(`[${new Date().toISOString()}] [${emailId}] Processed ${mailOptions.attachments.length} attachments in ${Date.now() - attachmentsStart}ms`);
      } catch (error) {
        console.error(`[${new Date().toISOString()}] [${emailId}] Error processing attachments:`, error);
        throw new Error(`Failed to process attachments: ${error.message}`);
      }
    }

    // Send email
    console.log(`[${new Date().toISOString()}] [${emailId}] Sending email to ${options.to} (attempt ${attempt}/${EMAIL_CONFIG.MAX_RETRIES + 1})`);

    const info = await new Promise((resolve, reject) => {
      mailTransporter.sendMail(mailOptions, (error, info) => {
        if (error) {
          reject(error);
        } else {
          resolve(info);
        }
      });
    });

    // Log success
    const duration = Date.now() - startTime;
    console.log(`[${new Date().toISOString()}] [${emailId}] Email sent successfully in ${duration}ms`, {
      messageId: info.messageId,
      to: info.envelope.to,
      accepted: info.accepted,
      rejected: info.rejected,
      pending: info.pending,
      response: info.response,
    });

    return {
      success: true,
      messageId: info.messageId,
      emailId,
      accepted: info.accepted,
      rejected: info.rejected,
      pending: info.pending,
      response: info.response,
      envelope: info.envelope,
      duration,
      attempt,
    };
  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`[${new Date().toISOString()}] [${emailId}] Error sending email (attempt ${attempt}):`, error);

    // Check if we should retry
    const isTransientError =
      (error.responseCode && error.responseCode >= 500) || // SMTP server error
      error.code === 'ECONNECTION' || // Connection error
      error.code === 'ETIMEDOUT' || // Timeout
      error.code === 'ECONNRESET' || // Connection reset
      error.code === 'EAUTH' || // Authentication error (might be temporary)
      error.code === 'EENVELOPE' || // Envelope error
      (error.response && error.response.startsWith('4')); // 4xx SMTP response

    if (isTransientError && attempt <= EMAIL_CONFIG.MAX_RETRIES) {
      const delayMs = calculateDelay(attempt - 1);
      console.warn(`[${new Date().toISOString()}] [${emailId}] Retrying email (attempt ${attempt + 1}/${EMAIL_CONFIG.MAX_RETRIES}) in ${delayMs}ms...`);
      await delay(delayMs);
      return sendEmail(options, attempt);
    }

    // Log final failure
    console.error(`[${new Date().toISOString()}] [${emailId}] Failed to send email after ${attempt} attempts in ${duration}ms`, {
      error: error.message,
      code: error.code,
      responseCode: error.responseCode,
      command: error.command,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
    });

    // Return structured error response
    const errorResponse = {
      success: false,
      error: error.message,
      code: error.code,
      responseCode: error.responseCode,
      emailId,
      attempt,
      duration,
      message: `Failed to send email: ${error.message}`,
    };

    // Add more context for common errors
    if (error.code === 'EAUTH') {
      errorResponse.message = 'Email authentication failed. Please check your email credentials.';
    } else if (error.code === 'EENVELOPE') {
      errorResponse.message = 'Invalid email envelope. Please check the recipient email addresses.';
    } else if (error.responseCode === 550) {
      errorResponse.message = 'Recipient email address rejected by the server. Please verify the email address.';
    } else if (error.code === 'ETIMEDOUT') {
      errorResponse.message = 'Email server connection timed out. Please try again later.';
    }

    throw errorResponse;
  }
};

/**
 * Queue an email to be sent (wrapper around sendEmail for backward compatibility)
 * @param {Object} options - Email options (same as sendEmail)
 * @returns {Promise<Object>} Email sending result
 */
const queueEmail = async (options) => {
  // Just pass through to sendEmail for now
  return sendEmail(options);
};

// Test utilities
const clearCaches = () => {
  emailCache.flushAll();
  templateRenderCache.flushAll();
};

const _test = { clearCaches };

// Export all public functions
module.exports = { 
  sendEmail, 
  queueEmail,
  compileTemplate,
  renderTemplate,
  processAttachments,
  fetchImage,
  getTransporter,
  isValidEmail,
  _test
};\n