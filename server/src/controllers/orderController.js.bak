import { getClient, query } from '../db/index.js';
import { v4 as uuidv4 } from 'uuid';
import { whatsappService } from '../services/whatsapp.service.js';
import pool from '../db/index.js';

// Valid order statuses
const ORDER_STATUS = {
  PENDING: 'pending',
  PROCESSING: 'processing',
  SHIPPED: 'shipped',
  DELIVERED: 'delivered',
  CANCELLED: 'cancelled',
  COMPLETED: 'completed'
};

// Valid payment statuses
const PAYMENT_STATUS = {
  PENDING: 'pending',
  PAID: 'paid',
  FAILED: 'failed',
  REFUNDED: 'refunded',
  PARTIALLY_REFUNDED: 'partially_refunded'
};

// Get all orders for a buyer
export async function getBuyerOrders(req, res) {
  console.log('\n=== START getBuyerOrders ===');
  console.log('Request URL:', req.originalUrl);
  console.log('Request query params:', req.query);
  console.log('Authenticated user:', req.user);
  console.log('Request headers:', req.headers);
  console.log('Request method:', req.method);
  console.log('Request path:', req.path);
  console.log('Request baseUrl:', req.baseUrl);
  console.log('Request originalUrl:', req.originalUrl);
  
  try {
    const buyerId = req.user.id; // Use authenticated user's ID
    const { status, limit = 10, offset = 0, sortBy = 'created_at', sortOrder = 'desc' } = req.query;
    
    console.log('\n[1/4] Fetching orders with params:', { 
      buyerId, 
      status, 
      limit, 
      offset, 
      sortBy, 
      sortOrder 
    });
    
    // Get the total count of orders for pagination
    console.log('\n[2/4] Building count query');
    const countQuery = `
      SELECT COUNT(*) as total 
      FROM orders 
      WHERE buyer_id = $1
      ${status ? 'AND LOWER(status) = $2' : ''}
    `;
    console.log('Count query:', countQuery);
    console.log('Count params:', status ? [buyerId, status.toLowerCase()] : [buyerId]);
    
    const countParams = [buyerId];
    if (status) countParams.push(status.toLowerCase());
    
    // Get total count of orders for this customer
    console.log('\n[3/4] Executing count query...');
    const countResult = await query(countQuery, countParams);
    const totalOrders = parseInt(countResult.rows[0]?.total || 0);
    console.log('Total orders found:', totalOrders);
    
    // If no orders found, return empty result
    if (totalOrders === 0) {
      return res.json({
        success: true,
        data: [],
        pagination: {
          total: 0,
          limit: parseInt(limit),
          offset: parseInt(offset),
          total_pages: 0
        }
      });
    }
    
    // Get the paginated order IDs first
    console.log('\n[4/4] Building order details query');
    const orderIdsQuery = `
      SELECT id 
      FROM orders 
      WHERE buyer_id = $1
      ${status ? 'AND LOWER(status) = $2' : ''}
      ORDER BY ${sortBy} ${sortOrder.toUpperCase()}
      LIMIT $${status ? '3' : '2'} OFFSET $${status ? '4' : '3'}
    `;
    
    const orderIdsParams = [buyerId];
    if (status) orderIdsParams.push(status.toLowerCase());
    orderIdsParams.push(parseInt(limit), parseInt(offset));
    
    console.log('Order IDs query:', orderIdsQuery);
    console.log('Order IDs params:', orderIdsParams);
    
    console.log('\n[5/5] Fetching order IDs...');
    const orderIdsResult = await query(orderIdsQuery, orderIdsParams);
    const orderIds = orderIdsResult.rows.map(row => row.id);
    
    if (orderIds.length === 0) {
      console.log('No orders found for the given criteria');
      return res.json({
        success: true,
        data: [],
        pagination: {
          total: totalOrders,
          limit: parseInt(limit),
          offset: parseInt(offset),
          total_pages: Math.ceil(totalOrders / parseInt(limit))
        }
      });
    }
    
    console.log('Found order IDs:', orderIds);
    
    // Now get the complete order details with items for the paginated order IDs
    const orderDetailsQuery = `
      SELECT 
        o.id,
        o.merchant_reference as order_number,
        o.total_amount as total_amount,
        o.total_amount as subtotal,
        0 as shipping_cost,
        0 as tax_amount,
        0 as discount_amount,
        LOWER(o.status) as status,
        LOWER(o.payment_status) as payment_status,
        o.status_updated_at,
        o.created_at,
        o.updated_at,
        o.customer_email as email,
        o.customer_first_name as first_name,
        o.customer_last_name as last_name,
        o.customer_phone as phone,
        o.billing_address,
        o.currency,
        o.buyer_id as customer_id,
        COALESCE(
          (
            SELECT json_agg(
              json_build_object(
                'id', oi.id,
                'product_id', oi.product_id,
                'product_name', oi.product_name,
                'product_description', oi.product_description,
                'product_price', oi.product_price,
                'quantity', oi.quantity,
                'subtotal', oi.subtotal,
                'status', oi.status,
                'created_at', oi.created_at,
                'updated_at', oi.updated_at
              )
            )
            FROM order_items oi 
            WHERE oi.order_id = o.id
          ),
          '[]'::json
        ) as items
      FROM orders o
      WHERE o.id = ANY($1)
      ORDER BY o.created_at DESC
    `;
    
    console.log('\n[6/6] Fetching order details...');
    console.log('Order details query:', orderDetailsQuery);
    console.log('Order details params:', [orderIds]);
    
    const startTime = Date.now();
    const result = await query(orderDetailsQuery, [orderIds]);
    const queryTime = Date.now() - startTime;
    
    console.log(`Query executed in ${queryTime}ms`);
    console.log('Number of orders found:', result.rows.length);
    
    if (result.rows.length > 0) {
      console.log('First order sample:', {
        id: result.rows[0].id,
        order_number: result.rows[0].order_number,
        status: result.rows[0].status,
        items_count: result.rows[0].items ? result.rows[0].items.length : 0
      });
    }
    
    const orders = result.rows.map(row => {
      // Transform billing_address from JSONB to the expected format
      if (row.billing_address && typeof row.billing_address === 'object') {
        row.billing_address = {
          first_name: row.first_name,
          last_name: row.last_name,
          email: row.email,
          phone: row.phone,
          ...row.billing_address
        };
      }
      return row;
    });
    
    console.log('Processed orders:', { count: orders.length, totalOrders });
    
    const response = {
      success: true,
      data: orders,
      pagination: {
        total: totalOrders, // Use the totalOrders from the count query
        limit: parseInt(limit),
        offset: parseInt(offset),
        total_pages: Math.ceil(totalOrders / parseInt(limit))
      }
    };
    
    console.log('\n=== END getBuyerOrders ===');
    console.log(`Returning ${orders.length} orders out of ${totalOrders} total`);
    
    res.json(response);
  } catch (error) {
    console.error('Error fetching buyer orders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch orders',
      error: error.message
    });
  }
};

// Get order details by ID
const getOrderDetails = async (req, res) => {
  try {
    const { orderId } = req.params;
    
    // Get order with buyer verification if buyerId is provided
    const { buyerId } = req.query;
    let query = 'SELECT * FROM orders WHERE id = $1';
    const queryParams = [orderId];
    
    if (buyerId) {
      // Verify the buyer exists
      const buyerCheck = await db.query('SELECT id FROM buyers WHERE id = $1', [buyerId]);
      if (buyerCheck.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Buyer not found'
        });
      }
      
      query += ' AND buyer_id = $2';
      queryParams.push(buyerId);
    }
    
    // Get order with the constructed query
    const orderResult = await db.query(query, queryParams);
    
    if (orderResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }
    
    const order = orderResult.rows[0];
    
    // Get order items
    const itemsResult = await db.query(
      'SELECT * FROM order_items WHERE order_id = $1',
      [orderId]
    );
    
    // Derive status history from the orders table
    const statusHistoryResult = { rows: [] };
    
    // Add current status to history
    if (order.status) {
      statusHistoryResult.rows.push({
        status: order.status,
        notes: 'Current status',
        created_at: order.status_updated_at || order.created_at,
        changed_by: order.status_updated_by || 'system'
      });
      
      // If status was updated, add the initial status as well
      if (order.status_updated_at && order.status_updated_at !== order.created_at) {
        statusHistoryResult.rows.push({
          status: 'pending',
          notes: 'Order created',
          created_at: order.created_at,
          changed_by: 'system'
        });
      }
    }
    
    // Get payment history
    const paymentsResult = await db.query(
      'SELECT * FROM order_payments WHERE order_id = $1 ORDER BY created_at DESC',
      [orderId]
    );
    
    res.json({
      success: true,
      data: {
        ...order,
        items: itemsResult.rows,
        payments: paymentsResult.rows,
        statusHistory: statusHistoryResult.rows
      }
    });
  } catch (error) {
    console.error('Error fetching order details:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch order details',
      error: error.message
    });
  }
};

// Create a new order
export async function addOrderItemsAfterPayment(client, order) {
  try {
    // 1. Check if order items already exist to prevent duplicates
    const itemsResult = await client.query(
      'SELECT COUNT(*) FROM order_items WHERE order_id = $1',
      [order.id]
    );
    const itemCount = parseInt(itemsResult.rows[0].count, 10);

    if (itemCount > 0) {
      logger.info(`Order items for order ${order.id} already exist. Skipping creation.`);
      return;
    }

    // 2. Parse metadata
    const metadata = typeof order.metadata === 'string' ? JSON.parse(order.metadata) : order.metadata || {};
    const items = Array.isArray(metadata.items) ? metadata.items : [];

    if (items.length === 0) {
      logger.warn(`No items found in metadata for completed order ${order.id}.`);
      return;
    }

    logger.info(`Adding ${items.length} items to order ${order.id}.`);

    // 3. Process each item and insert into the database
    for (const item of items) {
      if (item.productId && item.quantity) {
        // Fetch product details to ensure data integrity
        const productResult = await client.query(
          'SELECT name, price, description FROM products WHERE id = $1',
          [item.productId]
        );

        if (productResult.rows.length > 0) {
          const product = productResult.rows[0];
          const subtotal = parseFloat((product.price * item.quantity).toFixed(2));

          await client.query(
            `INSERT INTO order_items 
             (order_id, product_id, product_name, product_description, 
              product_price, quantity, subtotal, created_at, updated_at)
             VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())`,
            [
              order.id,
              item.productId,
              item.productName || product.name,
              item.productDescription || product.description || '',
              parseFloat(product.price.toFixed(2)),
              parseInt(item.quantity, 10),
              subtotal
            ]
          );
        }
      }
    }

    // 4. (Optional) Update order total amount based on items
    const totalResult = await client.query(
      'SELECT SUM(subtotal) as total FROM order_items WHERE order_id = $1',
      [order.id]
    );
    const total = parseFloat(totalResult.rows[0].total || '0');

    if (total > 0) {
      await client.query(
        'UPDATE orders SET amount = $1, updated_at = NOW() WHERE id = $2',
        [total, order.id]
      );
    }

    logger.info(`Successfully added items and updated total for order ${order.id}.`);

  } catch (error) {
    logger.error('Error in addOrderItemsAfterPayment:', {
      orderId: order.id,
      error: error.message,
      stack: error.stack
    });
    // We throw the error so the calling transaction can be rolled back
    throw error;
  }
};

export async function createOrder(req, res) {
  const client = await db.getClient();
  
  try {
    const { buyerId: paramBuyerId } = req.params;
    const { items, shippingAddress, billingAddress, notes } = req.body;
    
    // Use buyerId from params if not in body, but prefer body for backward compatibility
    const buyerId = paramBuyerId || req.body.buyerId;
    
    if (!buyerId) {
      return res.status(400).json({
        success: false,
        message: 'Buyer ID is required'
      });
    }
    
    // Verify the buyer exists
    const buyerCheck = await client.query('SELECT id FROM buyers WHERE id = $1', [buyerId]);
    if (buyerCheck.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Buyer not found'
      });
    }
    
    await client.query('BEGIN');
    
    // Calculate total amount
    let totalAmount = 0;
    const orderItems = [];
    
    // Validate items array
    if (!Array.isArray(items) || items.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Order must contain at least one item'
      });
    }
    
    // Start a transaction
    console.log('Starting transaction for order creation');
    await client.query('BEGIN');
    
    try {
      // Validate and prepare order items
      for (const item of items) {
        // Validate required fields
        if (!item.productId || !item.quantity) {
          throw new Error('Each order item must have a productId and quantity');
        }
        
        // Ensure quantity is a positive number
        const quantity = parseInt(item.quantity, 10);
        if (isNaN(quantity) || quantity <= 0) {
          throw new Error(`Invalid quantity for product ${item.productId}: must be a positive number`);
        }
        
        // Get product details with row-level locking to prevent race conditions
        const productResult = await client.query(
          'SELECT id, name, price, description, status, inventory_quantity FROM products WHERE id = $1 FOR UPDATE',
          [item.productId]
        );
        
        if (productResult.rows.length === 0) {
          throw new Error(`Product with ID ${item.productId} not found`);
        }
        
        const product = productResult.rows[0];
        
        // Check product availability
        if (product.status !== 'available') {
          throw new Error(`Product "${product.name}" is not available for purchase`);
        }
        
        // Check inventory if applicable
        if (product.inventory_quantity !== null && product.inventory_quantity < quantity) {
          throw new Error(`Insufficient inventory for product "${product.name}". Available: ${product.inventory_quantity}, Requested: ${quantity}`);
        }
        
        // Calculate subtotal
        const subtotal = parseFloat((product.price * quantity).toFixed(2));
        totalAmount = parseFloat((totalAmount + subtotal).toFixed(2));
        
        // Prepare order item
        const orderItem = {
          productId: product.id,
          productName: product.name,
          productDescription: item.productDescription || product.description || '',
          productPrice: parseFloat(product.price.toFixed(2)),
          quantity: quantity,
          subtotal: subtotal,
          metadata: item.metadata || {}
        };
        
        orderItems.push(orderItem);
        
        // Update product inventory if applicable
        if (product.inventory_quantity !== null) {
          const newQuantity = product.inventory_quantity - quantity;
          await client.query(
            'UPDATE products SET inventory_quantity = $1, updated_at = NOW() WHERE id = $2',
            [newQuantity, product.id]
          );
        }
      }
    
      // Generate unique references
      const merchantReference = `ORD-${uuidv4()}`;
      const orderTrackingId = `TRK-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      const paymentStatus = 'PENDING';
    
    // Prepare customer information
    const customerEmail = req.body.customerEmail || buyerCheck.rows[0].email || '';
    const customerPhone = req.body.customerPhone || billingAddress?.phone || shippingAddress?.phone || '';
    const customerFirstName = billingAddress?.firstName || shippingAddress?.firstName || buyerCheck.rows[0]?.first_name || '';
    const customerLastName = billingAddress?.lastName || shippingAddress?.lastName || buyerCheck.rows[0]?.last_name || '';
    
    // Create product description from order items
    const productDescription = orderItems
      .map(item => `${item.quantity}x ${item.productName}`)
      .join(', ');
    
    // Prepare Pesapal specific data
    const pesapalNotificationId = req.body.notificationId || `NOTIF-${Date.now()}`;
    const ipnNotificationType = req.body.ipnNotificationType || 'GET';
    const paymentMethod = req.body.paymentMethod || 'pesapal';
    const paymentMethodDescription = req.body.paymentMethodDescription || 'Pesapal Payment';
    
    // Create order with all fields
    const orderResult = await client.query(
      `INSERT INTO orders (
        -- Basic order info
        buyer_id, total_amount, currency, notes,
        
        -- References and tracking
        merchant_reference, order_tracking_id, 
        
        -- Payment info
        payment_status, payment_method, payment_method_description, payment_reference,
        notification_id, ipn_notification_type,
        
        -- Customer info
        customer_id, customer_email, customer_phone,
        customer_first_name, customer_last_name, country_code,
        
        -- Product info
        product_id, description,
        
        -- Addresses
        shipping_address, billing_address,
        
        -- Metadata
        metadata,
        
        -- Status
        status
      ) VALUES (
        $1, $2, $3, $4,   -- Basic info
        $5, $6,            -- References
        $7, $8, $9, $10,   -- Payment info
        $11, $12,          -- PesaPal specific
        $13, $14, $15,     -- Customer info
        $16, $17,          -- Customer names
        $18, $19,          -- Customer country
        $20, $21,          -- Product info
        $22, $23,          -- Addresses
        $24,               -- Metadata
        $25                -- Status
      ) RETURNING *`,
      [
        // Basic info
        buyerId,
        totalAmount,
        'KES',
        notes || null,
        
        // References
        merchantReference,
        orderTrackingId,
        
        // Payment info
        paymentStatus,
        'pesapal',
        'Pesapal Payment',
        null,  // payment_reference
        pesapalNotificationId,
        ipnNotificationType,
          
        // Customer info
        buyerId,
        customerEmail,
        customerPhone,
        customerFirstName,
        customerLastName,
        'KE',  // Default country code
        
        // Product info
        orderItems.length > 0 ? orderItems[0].productId : null,
        orderItems.length > 0 ? orderItems.map(item => `${item.quantity}x ${item.productName}`).join(', ') : '',
        
        // Addresses
        JSON.stringify(shippingAddress || {}),
        JSON.stringify({
            ...(billingAddress || shippingAddress || {}),
            phone: customerPhone,
            email: customerEmail,
            name: `${customerFirstName} ${customerLastName}`.trim()
        }),
        
        // Metadata
        JSON.stringify({
            created_via: 'api',
            source: 'web',
            ip_address: req.ip,
            user_agent: req.get('user-agent'),
            ...(req.body.metadata || {})
        }),
        
        // Status
        'pending'
      ]
    );
    
    const order = orderResult.rows[0];
    
    // Add order items
    console.log(`Processing ${orderItems.length} order items`);
    for (const item of orderItems) {
      try {
        console.log('Inserting order item:', {
          order_id: order.id,
          product_id: item.productId,
          quantity: item.quantity
        });
        
        const result = await client.query(
          `INSERT INTO order_items 
           (order_id, product_id, product_name, product_description, 
            product_price, quantity, subtotal, metadata, created_at, updated_at)
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW())
           RETURNING id`,
          [
            order.id,
            item.productId,
            item.productName,
            item.productDescription,
            item.productPrice,
            item.quantity,
            item.subtotal,
            JSON.stringify(item.metadata || {})
          ]
        );
        
        console.log('Order item inserted with ID:', result.rows[0].id);
      } catch (error) {
        console.error('Error inserting order item:', {
          error: error.message,
          stack: error.stack,
          item: item
        });
        throw new Error(`Failed to add item ${item.productName} to order: ${error.message}`);
      }
    }
    
    // Update the order with initial status and timestamps
      await client.query(
        `UPDATE orders 
         SET status = 'PENDING', 
             payment_status = 'PENDING',
             status_updated_at = CURRENT_TIMESTAMP,
             status_updated_by = 'system',
             updated_at = CURRENT_TIMESTAMP,
             metadata = jsonb_set(
               COALESCE(metadata, '{}'::jsonb), 
               '{status_updates}', 
               COALESCE(metadata->'status_updates', '[]'::jsonb) || 
                 jsonb_build_object(
                   'status', 'PENDING',
                   'timestamp', CURRENT_TIMESTAMP,
                   'updated_by', 'system'
                 )::jsonb
             )
         WHERE id = $1`,
        [order.id]
      );
      
      // Log the status change in the audit log
      await client.query(
        `INSERT INTO order_audit_log 
         (order_id, action, details, performed_by, created_at)
         VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)`,
        [
          order.id,
          'status_update',
          JSON.stringify({
            from: null,
            to: 'PENDING',
            notes: 'Order created'
          }),
          'system'
        ]
      );
      
      // Commit the transaction
      await client.query('COMMIT');
      
      // Get full order details
      const orderDetails = await getFullOrderDetails(client, order.id);
      
      // TODO: Trigger any post-order creation actions (e.g., send confirmation email, etc.)
      
      res.status(201).json({
        success: true,
        message: 'Order created successfully',
        data: orderDetails
      });
      
    } catch (error) {
      // Rollback the transaction on error
      await client.query('ROLLBACK');
      console.error('Error creating order:', error);
      
      // Re-throw the error to be caught by the outer try-catch
      throw error;
    }
    
  } catch (error) {
    console.error('Error in createOrder:', {
      message: error.message,
      stack: error.stack,
      requestBody: req.body
    });
    
    res.status(500).json({
      success: false,
      message: 'Failed to create order: ' + error.message,
      error: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  } finally {
    client.release();
  }
};

// Update order status
const updateOrderStatus = async (req, res) => {
  const client = await pool.connect();
  
  try {
    const { orderId } = req.params;
    const { status, notes, changedBy } = req.body;
    
    if (!status) {
      return res.status(400).json({
        success: false,
        message: 'Status is required'
      });
    }
    
    // Define valid statuses
    const validStatuses = ['pending', 'processing', 'shipped', 'delivered', 'cancelled', 'completed'];
    
    // Validate status
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        message: `Invalid status. Must be one of: ${validStatuses.join(', ')}`
      });
    }
    
    await client.query('BEGIN');
    
    // Get current order with FOR UPDATE to lock the row
    const orderResult = await client.query(
      'SELECT * FROM orders WHERE id = $1 FOR UPDATE',
      [orderId]
    );
    
    if (orderResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }
    
    const currentOrder = orderResult.rows[0];
    const currentStatus = currentOrder.status;
    
    // If status hasn't changed, just return the current order
    if (currentStatus === status) {
      await client.query('ROLLBACK');
      client.release();
      const orderDetails = await getFullOrderDetails(orderId);
      return res.json({
        success: true,
        message: `Order status is already set to ${status}`,
        data: orderDetails
      });
    }
    
    // Update order status and payment status directly in the orders table
    // Only update payment_status if it's not already set to a terminal state
    const updateResult = await client.query(
      `UPDATE orders 
       SET status = $1,
           payment_status = CASE 
             WHEN payment_status IN ('paid', 'failed', 'refunded', 'partially_refunded') 
             THEN payment_status 
             ELSE $1 
           END,
           status_updated_at = CURRENT_TIMESTAMP,
           status_updated_by = $2,
           updated_at = CURRENT_TIMESTAMP
       WHERE id = $3
       RETURNING *`,
      [status, changedBy || 'system', orderId]
    );
    
    if (updateResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({
        success: false,
        message: 'Failed to update order status'
      });
    }
    
    // Log the status change in the audit log
    await client.query(
      `INSERT INTO order_audit_log 
       (order_id, action, details, performed_by, created_at)
       VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)`,
      [
        orderId,
        'status_update',
        JSON.stringify({
          from: currentStatus,
          to: status,
          notes: notes || null
        }),
        changedBy || 'system'
      ]
    );
    
    // Commit the transaction
    await client.query('COMMIT');
    
    // Release the client before getting full order details (it will get its own connection)
    client.release();
    
    // Get full order details with items and payments
    const orderDetails = await getFullOrderDetails(orderId);
    
    // Send WhatsApp notifications based on status change
    try {
      // Ensure WhatsApp service is initialized
      await whatsappService.ensureInitialized();
      
      if (status === 'delivered' && orderDetails.customerPhone) {
        // Notify buyer that their order has been delivered
        try {
          await whatsappService.sendDeliveryNotificationToBuyer(
            orderDetails.customerPhone,
            {
              orderId: orderDetails.orderTrackingId || orderDetails.merchantReference,
              items: orderDetails.items || [],
              totalAmount: orderDetails.amount
            }
          );
        } catch (error) {
          console.error('Error sending delivery notification:', error);
        }
      } else if (status === 'processing' && orderDetails.items && orderDetails.items.length > 0) {
        // Notify seller about new order
        try {
          // First, get seller's phone number from the first product
          const productId = orderDetails.items[0].product_id;
          if (productId) {
            const sellerResult = await client.query(
              `SELECT s.phone, s.full_name as seller_name 
               FROM products p 
               JOIN sellers s ON p.seller_id = s.id 
               WHERE p.id = $1`,
              [productId]
            );
            
            if (sellerResult.rows.length > 0 && sellerResult.rows[0].phone) {
              const seller = sellerResult.rows[0];
              await whatsappService.sendOrderNotificationToSeller(
                seller.phone,
                {
                  orderId: orderDetails.orderTrackingId || orderDetails.merchantReference,
                  items: orderDetails.items.map(item => ({
                    name: item.product_name,
                    price: item.product_price,
                    quantity: item.quantity
                  })),
                  totalAmount: orderDetails.amount,
                  customerName: orderDetails.customerFirstName ? 
                    `${orderDetails.customerFirstName} ${orderDetails.customerLastName || ''}`.trim() : 
                    'a customer'
                }
              );
            }
          }
        } catch (error) {
          console.error('Error sending order notification to seller:', error);
        }
      }
    } catch (error) {
      console.error('Error with WhatsApp service:', error);
      // Don't fail the request if notification fails
    }
    
    res.json({
      success: true,
      message: 'Order status updated successfully',
      data: orderDetails
    });
    
  } catch (error) {
    try {
      await client.query('ROLLBACK');
    } catch (rollbackError) {
      console.error('Error rolling back transaction:', rollbackError);
    }
    
    console.error('Error updating order status:', error);
    
    // Only release the client if it hasn't been released yet
    if (client) {
      try {
        client.release();
      } catch (releaseError) {
        console.error('Error releasing client:', releaseError);
      }
    }
    
    res.status(500).json({
      success: false,
      message: 'Failed to update order status',
      error: error.message
    });
  }

// Helper function to get full order details
const getFullOrderDetails = async (orderId) => {
  const client = await pool.connect();
  
  try {
    // Get order details with all related data in a single query
    const orderResult = await client.query(
      `SELECT 
        o.*,
        COALESCE(
          json_agg(
            json_build_object(
              'id', oi.id,
              'product_id', oi.product_id,
              'product_name', oi.product_name,
              'product_description', oi.product_description,
              'product_price', oi.product_price,
              'quantity', oi.quantity,
              'subtotal', oi.subtotal,
              'metadata', oi.metadata,
              'created_at', oi.created_at,
              'updated_at', oi.updated_at
            )
          ) FILTER (WHERE oi.id IS NOT NULL),
          '[]'::json
        ) as items,
        json_build_object(
          'first_name', b.first_name,
          'last_name', b.last_name,
          'email', b.email,
          'phone', b.phone
        ) as buyer
      FROM 
        orders o
      LEFT JOIN 
        order_items oi ON o.id = oi.order_id
      LEFT JOIN
        buyers b ON o.buyer_id = b.id
      WHERE 
        o.id = $1
      GROUP BY 
        o.id, b.id`,
      [orderId]
    );
    
    if (orderResult.rows.length === 0) {
      return null;
    }
    
    const order = orderResult.rows[0];
    
    // Helper function to parse JSON fields
    const parseIfNeeded = (value) => {
      if (typeof value === 'string') {
        try {
          return JSON.parse(value);
        } catch (e) {
          return value;
        }
      }
      return value;
    };
    
    // Parse JSON fields
    order.metadata = parseIfNeeded(order.metadata);
    order.billing_address = parseIfNeeded(order.billing_address);
    order.shipping_address = parseIfNeeded(order.shipping_address);
    
    // Ensure items is always an array
    if (!order.items || !Array.isArray(order.items)) {
      order.items = [];
    }
    
    // Parse metadata in items
    order.items = order.items.map(item => ({
      ...item,
      metadata: parseIfNeeded(item.metadata)
    }));

    // Get status history from audit log
    const statusHistoryResult = await client.query(
      `SELECT 
        id,
        action,
        details,
        performed_by as "performedBy",
        created_at as "createdAt"
      FROM order_audit_log 
      WHERE order_id = $1 
      ORDER BY created_at DESC`,
      [orderId]
    );

    // Format the order response
    const formattedOrder = {
      id: order.id,
      merchantReference: order.merchant_reference,
      orderTrackingId: order.order_tracking_id,
      amount: parseFloat(order.total_amount || order.amount || 0),
      currency: order.currency,
      status: order.status,
      paymentStatus: order.payment_status,
      paymentMethod: order.payment_method,
      paymentReference: order.payment_reference,
      paymentDate: order.payment_date,
      customerId: order.customer_id,
      customerEmail: order.customer_email,
      customerPhone: order.customer_phone,
      customerFirstName: order.customer_first_name,
      customerLastName: order.customer_last_name,
      countryCode: order.country_code,
      productId: order.product_id,
      description: order.description,
      shippingAddress: order.shipping_address,
      billingAddress: order.billing_address,
      metadata: order.metadata || {},
      statusHistory: statusHistoryResult.rows,
      items: order.items,
      buyer: order.buyer,
      createdAt: order.created_at,
      updatedAt: order.updated_at,
      statusUpdatedAt: order.status_updated_at,
      statusUpdatedBy: order.status_updated_by,
      notes: order.notes
    };

    // Remove raw database fields
    delete formattedOrder.total_amount;
    delete formattedOrder.created_at;
    delete formattedOrder.updated_at;
    delete formattedOrder.status_updated_at;
    
    return formattedOrder;
  } catch (error) {
    console.error('Error getting full order details:', error);
    throw error;
  } finally {
    client.release();
  }
};

/**
 * @swagger
 * /api/orders/reference/{reference}:
 *   get:
 *     summary: Get order status by reference
 *     description: Public endpoint to check the status of an order using its reference number
 *     tags: [Orders]
 *     parameters:
 *       - in: path
 *         name: reference
 *         required: true
 *         schema:
 *           type: string
 *         description: The order reference number
 *     responses:
 *       200:
 *         description: Order status retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 status:
 *                   type: string
 *                   description: The current status of the order
 *                 message:
 *                   type: string
 *                   description: Additional message about the status
 *       404:
 *         description: Order not found
 *       500:
 *         description: Server error
 */
// Confirm an order (buyer confirms receipt)
const confirmOrder = async (req, res) => {
  const client = await getClient();
  
  try {
    const { orderId } = req.params;
    const { buyerId } = req.body;
    
    if (!buyerId) {
      return res.status(400).json({ 
        success: false, 
        message: 'Buyer ID is required' 
      });
    }
    
    // Start transaction
    await client.query('BEGIN');
    
    // Get order details
    const orderResult = await client.query(
      `SELECT id, buyer_id, status, payment_status, total_amount 
       FROM orders 
       WHERE id = $1 AND buyer_id = $2
       FOR UPDATE`,
      [orderId, buyerId]
    );
    
    if (orderResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ 
        success: false, 
        message: 'Order not found or access denied' 
      });
    }
    
    const order = orderResult.rows[0];
    
    // Check if order can be confirmed
    if (order.status !== 'delivered') {
      await client.query('ROLLBACK');
      return res.status(400).json({ 
        success: false, 
        message: 'Only delivered orders can be confirmed' 
      });
    }
    
    // Update order status to confirmed
    const now = new Date();
    const confirmedBy = `buyer:${buyerId}`;
    
    // First, update the status and updated_at
    await client.query(
      `UPDATE orders 
       SET status = $1, 
           updated_at = $2
       WHERE id = $3`,
      ['confirmed', now, orderId]
    );
    
    // Then update the metadata with explicit type casting
    await client.query(
      `UPDATE orders 
       SET metadata = COALESCE(metadata, '{}'::jsonb) || 
           jsonb_build_object(
             'confirmed_at', to_char($1::timestamp with time zone, 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"'::text),
             'confirmed_by', $2::text
           )
       WHERE id = $3`,
      [now, confirmedBy, orderId]
    );
    
    // Add audit log entry
    await client.query(
      `INSERT INTO order_audit_log 
       (order_id, action, details, performed_by, created_at) 
       VALUES ($1, $2, $3::jsonb, $4, $5)`,
      [
        orderId, 
        'STATUS_UPDATE', 
        JSON.stringify({
          status: 'confirmed',
          previous_status: order.status,
          message: 'Order confirmed by buyer'
        }),
        `buyer:${buyerId}`, 
        new Date()
      ]
    );
    
    // Update seller's balance (if applicable)
    if (order.payment_status === 'paid') {
      // Get all order items with seller information
      const itemsResult = await client.query(
        `SELECT oi.id, oi.product_id, oi.quantity, oi.price, 
                p.seller_id, p.price as product_price
         FROM order_items oi
         JOIN products p ON oi.product_id = p.id
         WHERE oi.order_id = $1`,
        [orderId]
      );
      
      // Group items by seller and update their balances
      const sellerTotals = {};
      itemsResult.rows.forEach(item => {
        const sellerId = item.seller_id;
        if (!sellerTotals[sellerId]) {
          sellerTotals[sellerId] = 0;
        }
        // Calculate 91% of the item total (9% platform fee)
        const sellerAmount = (item.price * item.quantity) * 0.91;
        sellerTotals[sellerId] += sellerAmount;
      });
      
      // Update each seller's balance
      for (const [sellerId, amount] of Object.entries(sellerTotals)) {
        await client.query(
          `UPDATE sellers 
           SET balance = COALESCE(balance, 0) + $1,
               updated_at = $2
           WHERE id = $3`,
          [amount, now, sellerId]
        );
        
        // Record the transaction
        await client.query(
          `INSERT INTO seller_transactions 
           (seller_id, order_id, amount, type, description)
           VALUES ($1, $2, $3, $4, $5)`,
          [
            sellerId, 
            orderId, 
            amount, 
            'sale', 
            `Sale from order #${orderId} (after 9% platform fee)`
          ]
        );
      }
    }
    
    await client.query('COMMIT');
    
    res.json({ 
      success: true, 
      message: 'Order confirmed successfully',
      data: {
        orderId,
        status: 'confirmed',
        confirmedAt: now.toISOString()
      }
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error confirming order:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to confirm order',
      error: error.message 
    });
  } finally {
    client.release();
  }
};

export async function getOrderStatusByReference(req, res) {
  try {
    const { reference } = req.params;
    
    if (!reference) {
      return res.status(400).json({
        success: false,
        message: 'Reference number is required'
      });
    }

    const result = await db.query(
      `SELECT 
        status, 
        payment_status,
        status_updated_at,
        created_at, 
        updated_at 
       FROM orders 
       WHERE merchant_reference = $1`,
      [reference]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Order not found with the provided reference'
      });
    }

    const order = result.rows[0];
    
    // Map database status to frontend status
    let status = order.status ? order.status.toLowerCase() : 'pending';
    let message = `Order is ${status}`;
    
    if (order.payment_status) {
      const paymentStatus = order.payment_status.toLowerCase();
      message = `Payment is ${paymentStatus}`;
      
      // Map payment status to frontend status
      if (paymentStatus === 'paid' || paymentStatus === 'completed') {
        status = 'success';
        message = 'Payment completed successfully';
      } else if (paymentStatus === 'failed' || paymentStatus === 'error' || paymentStatus === 'invalid') {
        status = 'error';
        message = 'Payment failed. Please try again.';
      } else if (paymentStatus === 'pending' || paymentStatus === 'processing') {
        status = 'pending';
        message = 'Payment is being processed. Please wait...';
      }
    }

    res.json({
      success: true,
      status,
      message,
      updatedAt: order.updated_at || order.created_at
    });
    
  } catch (error) {
    console.error('Error getting order status by reference:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get order status',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};
