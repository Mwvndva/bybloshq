import { v4 as uuidv4 } from 'uuid';
import logger from '../utils/logger.js';
import { pool } from '../config/database.js';
import pesapalService from '../services/pesapal.service.js';

class PesapalController {
  // Initialize Pesapal (register IPN)
  initialize = async (req, res) => {
    try {
      const publicUrl = process.env.PUBLIC_BASE_URL;
      if (!publicUrl) {
        throw new Error('PUBLIC_BASE_URL is not set in environment variables');
      }

      const ipnUrl = `${publicUrl}/api/pesapal/ipn`;
      
      const result = await pesapalService.registerIPN(ipnUrl);
      
      res.json({
        success: true,
        data: result,
        message: 'Pesapal IPN registered successfully'
      });
    } catch (error) {
      logger.error('Error initializing Pesapal:', error);
      res.status(500).json({
        success: false,
        message: error.message || 'Failed to initialize Pesapal',
        error: process.env.NODE_ENV === 'development' ? error.stack : undefined
      });
    }
  };

  // Process checkout
  checkout = async (req, res) => {
    const client = await pool.connect();
    
    try {
      const { amount, description, customer, productId } = req.body;
      
      // Basic validation
      if (!amount || !description || !customer || !customer.email) {
        return res.status(400).json({
          success: false,
          message: 'Missing required fields: amount, description, and customer with email are required'
        });
      }

      await client.query('BEGIN');
      
      // Generate a unique reference
      const merchantReference = `ORD-${uuidv4()}`;
      
      // Prepare the order payload for Pesapal
      const orderPayload = {
        id: merchantReference,
        currency: 'KES',
        amount: parseFloat(amount).toFixed(2),
        description: description.substring(0, 100), // Max 100 chars
        callback_url: `${process.env.PUBLIC_BASE_URL}/api/pesapal/callback`,
        notification_id: process.env.PESAPAL_NOTIFICATION_ID,
        billing_address: {
          email_address: customer.email,
          phone_number: customer.phone || '',
          country_code: customer.countryCode || 'KE',
          first_name: customer.firstName || 'Customer',
          middle_name: '',
          last_name: customer.lastName || 'Byblos',
          line_1: 'N/A',
          line_2: '',
          city: '',
          state: '',
          postal_code: '',
          zip_code: ''
        },
        // Specify M-Pesa as the preferred payment method
        preferred_payment_option: 'mpesa',
        // Additional payment methods configuration
        payment_methods: ['mpesa'],
        // Required for M-Pesa payments
        ipn_notification_type: 'POST',
        // Add metadata
        metadata: {
          product_id: productId,
          customer_id: customer.id,
          payment_method: 'mpesa',
          payment_channel: 'mobile_money',
          payment_provider: 'safaricom',
          payment_country: 'KE'
        },
        // Required for M-Pesa payments
        payment_options: {
          payment_method: 'mpesa',
          mpesa: {
            phone_number: customer.phone || '',
            callback_url: `${process.env.PUBLIC_BASE_URL}/api/pesapal/mpesa-callback`
          }
        }
      };

      // Save the order to the database
      const orderQuery = `
        INSERT INTO orders (
          merchant_reference, amount, currency, status, 
          customer_email, customer_phone, product_id, payment_method
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, 'pesapal')
        RETURNING id, merchant_reference, amount, currency, status, created_at
      `;
      
      const orderValues = [
        merchantReference,
        orderPayload.amount,
        orderPayload.currency,
        'PENDING',
        customer.email,
        customer.phone || null,
        productId || null
      ];

      const orderResult = await client.query(orderQuery, orderValues);
      const order = orderResult.rows[0];

      // Submit the order to Pesapal
      const pesapalResponse = await pesapalService.submitOrder(orderPayload);
      
      // Update the order with the Pesapal tracking ID
      await client.query(
        'UPDATE orders SET payment_reference = $1 WHERE id = $2',
        [pesapalResponse.order_tracking_id, order.id]
      );

      await client.query('COMMIT');
      
      res.json({
        success: true,
        data: {
          redirect_url: pesapalResponse.redirect_url,
          order_tracking_id: pesapalResponse.order_tracking_id,
          merchant_reference: merchantReference,
          order_id: order.id,
        },
        message: 'Order created successfully. Redirect to payment.'
      });
      
    } catch (error) {
      await client.query('ROLLBACK');
      logger.error('Checkout error:', error);
      
      res.status(500).json({
        success: false,
        message: error.message || 'Failed to process checkout',
        error: process.env.NODE_ENV === 'development' ? error.stack : undefined
      });
    } finally {
      client.release();
    }
  };

  // Handle Pesapal callback
  callback = async (req, res) => {
    try {
      const { OrderTrackingId, OrderMerchantReference } = req.query;
      const frontendUrl = process.env.PUBLIC_BASE_URL || 'http://localhost:3000';
      
      if (!OrderTrackingId || !OrderMerchantReference) {
        return res.redirect(`${frontendUrl}/checkout?status=error&message=Missing required parameters`);
      }

      // Get the latest status from Pesapal
      const status = await pesapalService.getOrderStatus(OrderTrackingId);
      
      // Update the order status in the database
      await pool.query(
        'UPDATE orders SET status = $1, payment_reference = $2, updated_at = NOW() WHERE merchant_reference = $3 RETURNING id',
        [status.payment_status_description, OrderTrackingId, OrderMerchantReference]
      );
      
      // Determine the status parameter based on Pesapal status
      let statusParam = 'pending';
      if (status.payment_status_description === 'COMPLETED') {
        statusParam = 'success';
      } else if (status.payment_status_description === 'FAILED' || status.payment_status_description === 'INVALID') {
        statusParam = 'error';
      }
      
      // Build the redirect URL with query parameters
      const redirectUrl = new URL(`${frontendUrl}/checkout`);
      redirectUrl.searchParams.append('status', statusParam);
      redirectUrl.searchParams.append('reference', OrderMerchantReference);
      
      if (statusParam === 'error') {
        redirectUrl.searchParams.append('message', status.payment_status_description || 'Payment processing failed');
      }
      
      logger.info(`Redirecting to frontend: ${redirectUrl.toString()}`);
      return res.redirect(redirectUrl.toString());
      
    } catch (error) {
      logger.error('Callback error:', error);
      const frontendUrl = process.env.PUBLIC_BASE_URL || 'http://localhost:3000';
      const redirectUrl = new URL(`${frontendUrl}/checkout`);
      redirectUrl.searchParams.append('status', 'error');
      redirectUrl.searchParams.append('message', error.message || 'An unexpected error occurred');
      return res.redirect(redirectUrl.toString());
    }
  };

  // Handle Pesapal IPN (Instant Payment Notification)
  ipnHandler = async (req, res) => {
    try {
      const { OrderNotificationType, OrderTrackingId, OrderMerchantReference } = req.body;
      
      if (OrderNotificationType !== 'IPN' || !OrderTrackingId || !OrderMerchantReference) {
        return res.status(400).json({
          success: false,
          message: 'Invalid IPN data'
        });
      }

      // Get the latest status from Pesapal
      const status = await pesapalService.getOrderStatus(OrderTrackingId);
      

    await client.query('COMMIT');
    
    res.json({
      success: true,
      data: {
        redirect_url: pesapalResponse.redirect_url,
        order_tracking_id: pesapalResponse.order_tracking_id,
        merchant_reference: merchantReference,
        order_id: order.id,
      },
      message: 'Order created successfully. Redirect to payment.'
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    logger.error('Checkout error:', error);
    
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to process checkout',
      error: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  } finally {
    client.release();
  }
};
        'SELECT * FROM orders WHERE id = $1',
        [orderId]
      );
      
      if (orderResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Order not found'
        });
      }
      
      const order = orderResult.rows[0];
      
      // If we have a payment reference, check with Pesapal for the latest status
      if (order.payment_reference) {
        try {
          const status = await pesapalService.getOrderStatus(order.payment_reference);
          
          // Update the order status in the database if it has changed
          if (status.payment_status_description !== order.status) {
            await pool.query(
              'UPDATE orders SET status = $1, updated_at = NOW() WHERE id = $2',
              [status.payment_status_description, order.id]
            );
            order.status = status.payment_status_description;
          }
          
          return res.json({
            success: true,
            data: {
              ...order,
              pesapal_status: status
            }
          });
          
        } catch (error) {
          logger.error('Error checking status with Pesapal:', error);
          // Continue to return the order with the current status from the database
        }
      }
      
      // Return the order with the current status from the database
      res.json({
        success: true,
        data: order
      });
      
    } catch (error) {
      logger.error('Check status error:', error);
      res.status(500).json({
        success: false,
        message: error.message || 'Failed to check order status'
      });
    }
  };

  // Test endpoint to verify PesaPal connection
  testConnection = async (req, res) => {
    try {
      // Test getting a token
      const token = await pesapalService.getToken();
      
      // Test IPN registration
      const publicUrl = process.env.PUBLIC_BASE_URL;
      const ipnUrl = `${publicUrl}/api/pesapal/ipn`;
      const ipnResult = await pesapalService.registerIPN(ipnUrl);
      
      res.json({
        success: true,
        message: 'PesaPal connection successful',
        token: token ? 'Token received successfully' : 'No token received',
        ipnRegistration: ipnResult || 'IPN registration successful',
        environment: process.env.NODE_ENV,
        baseUrl: process.env.PESAPAL_BASE_URL
      });
    } catch (error) {
      logger.error('PesaPal connection test failed:', error);
      res.status(500).json({
        success: false,
        message: 'PesaPal connection test failed',
        error: error.message,
        stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
      });
    }
  };
}

export default new PesapalController();
